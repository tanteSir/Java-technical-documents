## Hashmap底层数据结构

@author	Lin.cx         @date 		2019.9.10

```java
	已知 HashMap数据结构是 数组+单向链表（jdk1.7）  数组+单向链表+红黑树（jdk1.8）
	数组里存放的每个对象可以用 Node表示，像源代码里是这样写的：
    Node<K,V> implements Map<K,V>{
    	final int hash;		//这是计算出来的hash值
    	final K key;		//这是键对象
    	V value;			//这是值对象
    	Node<K,V> next;		//指向下一个Node对象，从这里可以看出这是单向链表
    }
    
	这里抛出一个问题？HashMap的 put动作是怎么将数据放进去的？
```



#### 一、put动作是怎么把数据放进HashMap中去的？

```java
1）首先是创建一个数据
2）然后是创建一个Node对象
3）通过 hash算法得到这个对象的 hash值，将结果转化为二进制，有32位，假设与数组的size-1进行“与”运算
    疑问：为什么要进行“与”运算呢？
    因为与二进制进行“与”运算后，结果范围是 0 ~ size-1的二进制数值，这样下标必定会在数组内
    不过得到的hash结果相同相同的可能性还是比较大的（因为最后几位数字相同）。那么有什么办法可以降低下标重复的可能性呢?
    所以需要先采用高16位与低16位进行异或运算("^")，充分运用左边的数值，这样能降低下标重复的可能性，最后再取与数组大小-1的“与”运算结果，这个值就是下标值 index
    这时候想到一个问题，为什么不用Random，而是要用hash呢？
   	使用hash算法比Random算法在 get方面好多了，并且重复可能性会降到最低，Random随机性太高，可能存在过于不理想的情况，如放进去的数据都随机得到了同一个下标，这样对性能是极大的浪费！
    源码取高低16位“亦或”运算是这样写的：
    static final int hash(Object key){
		int h;
		return (key == null?)? 0:(h = key.hashCode())^(h>>>16);	//左移16位得到高16位
	}
   
	这里又提出一个疑问，为什么数组大小必须是2的n次方，这是为什么？
   	首先我们的目的是index要尽可能不重复。然后再看二进制“与”运算的过程
        如：
        110011001...11011		//这是32长度的二进制
        			01111		//这是数组长度为16，-1后的二进制数值
        			abcde
        ------------------------
        倒过来想想，如果数组数值在d位置为0，那么会有什么影响？
        由于是进行“与”运算，所以d为0时，得到的结果恒为0，这样我们就不能很好的吧hash值d位置的数据用起来，无论它是0还是1，结果都是0，这样index重复的可能性就会多一分。所以我们需要0111...这样的数组二进制
        01  011  0111  01111  011111		//二进制数据
        2^0 2^1   2^2    2^3     2^4		//对应2的N次方
        从这里可以看出，数组大小必须是2的N次方，是有科学依据的！
    
4）根据得到的 index，将对应Node对象存储在对应位置内
	1.原来下标位置没有Node，那就直接放进去
	2.原来下标位置有Node，Key值相同，则替换value值
	3.原来下标位置有Node，Key值不同，则以单向链表方式进行存储，让前一个节点的next = new Node();
	链表太长会影响 put和查询性能。如果链表长度超过8，那就将链表转化为红黑树，反之如果红黑树节点小于6，那也会转回链表，这当中创建红黑树消耗的内存也是比较大的。
	
	这个put动作讲完了，那抛出下一个问题。当对象一直在加入hashMap，复杂度越来越高，那扩容就是必须执行的一件事，请问是如何进行扩容的？什么时候进行扩容？以及当中是怎么操作的？
```



#### 二、扩容问题，什么时候进行扩容？操作顺序？

```java
1）当数据结构中 Node节点数超过 数组长度 * 0.75的值时，进行扩容
2）创建一个新数组，大小为原数组的 2 的n次方倍
3）迁移数据：
   1.遍历老数组的索引位置，找到索引不为空的 Node
   2.对索引不为空的 Node索引位置进行判断
   	 a.下面没有Node，next == null
     b.下面有Node，是链表的连接方式
     c.下面有Node，是红黑树的连接方式
   这里需要注意的是，移动链表和红黑树中的Node对象，不能直接移动整个结构，而是要遍历重新计算位置，举个例子：原数组是16位大小的，那它判断的hash值倒数第五位就存在可能是0也可能是1的问题，这对原数组没印象，但是用数组计算新位置时，就会造成两边不一样的情况，如果原先是第n位，扩容后它就可能是第n位或者n+16位
 
    如：
 		0111010...010001
    			   01111	//这是原先的数组，得到结果00001
    
    	0111010...010001
    			  011111	//这是扩容后的数组，现在需要重新计算下标值，得到结果010001
    可以看出，同样的hash二进制数组，从右往左第五位的结果是不同的，因此最终得到的结果也将不同，为16+N
    
    并且需要知道的是，扩容是线程不安全的，所以需要用synchronized修饰每个单元格列的对象，这样锁粒度小，因为锁对象不同，所以效率也会高
```

